// src/sdMetadataExtractor.js

/**
 * ComfyUI Stable Diffusion Metadata Extractor
 * Extracts workflow and prompt metadata from WebP files generated by ComfyUI
 */

/**
 * Extract SD metadata from an image file
 * @param {File|Blob} file - Image file to extract metadata from
 * @returns {Promise<Object>} Metadata object with parsed parameters
 */
export async function extractSDMetadata(file) {
    const result = {
        hasSDMetadata: false,
        rawMetadata: null,
        parsedParameters: {},
        workflowData: null,
        error: null
    };

    try {
        // Read file as array buffer
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);

        // Extract WebP metadata chunks
        const webpMetadata = extractWebPMetadata(uint8Array);

        if (!webpMetadata) {
            return result;
        }

        // Look for ComfyUI workflow and prompt data
        const workflowJson = webpMetadata.workflow;
        const promptJson = webpMetadata.prompt;

        if (!workflowJson && !promptJson) {
            return result;
        }

        result.hasSDMetadata = true;
        result.rawMetadata = webpMetadata;

        // Parse ComfyUI workflow
        if (workflowJson) {
            try {
                result.workflowData = JSON.parse(workflowJson);
            } catch (e) {
                result.error = `Failed to parse workflow JSON: ${e.message}`;
            }
        }

        // Parse ComfyUI prompt data
        let promptData = null;
        if (promptJson) {
            try {
                promptData = JSON.parse(promptJson);
            } catch (e) {
                result.error = `Failed to parse prompt JSON: ${e.message}`;
            }
        }

        // Extract parameters from workflow and prompt data
        result.parsedParameters = parseComfyUIParameters(result.workflowData, promptData);

    } catch (error) {
        result.error = `Metadata extraction failed: ${error.message}`;
    }

    return result;
}

/**
 * Extract metadata chunks from WebP file
 * @param {Uint8Array} data - WebP file data
 * @returns {Object|null} Metadata object or null if no metadata found
 */
function extractWebPMetadata(data) {
    // WebP file signature
    if (data.length < 12 ||
        String.fromCharCode(...data.slice(0, 4)) !== 'RIFF' ||
        String.fromCharCode(...data.slice(8, 12)) !== 'WEBP') {
        return null;
    }

    const metadata = {};
    let offset = 12;

    // Parse WebP chunks
    while (offset < data.length - 8) {
        const chunkId = String.fromCharCode(...data.slice(offset, offset + 4));
        const chunkSize = data[offset + 4] | (data[offset + 5] << 8) |
                         (data[offset + 6] << 16) | (data[offset + 7] << 24);

        offset += 8;

        if (offset + chunkSize > data.length) {
            break;
        }

        // Look for text chunks that might contain ComfyUI data
        if (chunkId === 'EXIF') {
            // EXIF data might contain ComfyUI workflow
            const exifData = parseEXIFData(data.slice(offset, offset + chunkSize));
            if (exifData.workflow) metadata.workflow = exifData.workflow;
            if (exifData.prompt) metadata.prompt = exifData.prompt;
        } else if (chunkId === 'XMP ') {
            // XMP data
            const xmpString = new TextDecoder('utf-8').decode(data.slice(offset, offset + chunkSize));
            const xmpData = parseXMPData(xmpString);
            if (xmpData.workflow) metadata.workflow = xmpData.workflow;
            if (xmpData.prompt) metadata.prompt = xmpData.prompt;
        }

        // Move to next chunk (with padding)
        offset += chunkSize;
        if (chunkSize % 2) offset++; // WebP chunks are padded to even length
    }

    // Try alternative approach - look for JSON strings in the entire file
    if (!metadata.workflow && !metadata.prompt) {
        const fileString = new TextDecoder('utf-8', { fatal: false }).decode(data);

        // Look for ComfyUI workflow JSON pattern
        const workflowMatch = findJSONInString(fileString, 'workflow');
        if (workflowMatch) {
            metadata.workflow = workflowMatch;
        }

        // Look for ComfyUI prompt JSON pattern
        const promptMatch = findJSONInString(fileString, 'prompt');
        if (promptMatch) {
            metadata.prompt = promptMatch;
        }
    }

    return Object.keys(metadata).length > 0 ? metadata : null;
}

/**
 * Parse EXIF data for ComfyUI metadata
 * @param {Uint8Array} exifData - EXIF data chunk
 * @returns {Object} Parsed EXIF data
 */
function parseEXIFData(exifData) {
    const result = {};

    try {
        // Convert EXIF data to string and look for JSON
        const exifString = new TextDecoder('utf-8', { fatal: false }).decode(exifData);

        // Look for workflow JSON
        const workflowMatch = findJSONInString(exifString, 'workflow');
        if (workflowMatch) result.workflow = workflowMatch;

        // Look for prompt JSON
        const promptMatch = findJSONInString(exifString, 'prompt');
        if (promptMatch) result.prompt = promptMatch;

    } catch (e) {
        // Ignore parsing errors
    }

    return result;
}

/**
 * Parse XMP data for ComfyUI metadata
 * @param {string} xmpString - XMP data as string
 * @returns {Object} Parsed XMP data
 */
function parseXMPData(xmpString) {
    const result = {};

    // Look for workflow JSON in XMP
    const workflowMatch = findJSONInString(xmpString, 'workflow');
    if (workflowMatch) result.workflow = workflowMatch;

    // Look for prompt JSON in XMP
    const promptMatch = findJSONInString(xmpString, 'prompt');
    if (promptMatch) result.prompt = promptMatch;

    return result;
}

/**
 * Find JSON data in a string, looking for ComfyUI patterns
 * @param {string} str - String to search in
 * @param {string} type - Type of JSON to look for ('workflow' or 'prompt')
 * @returns {string|null} JSON string if found
 */
function findJSONInString(str, type) {
    // Look for JSON objects that start with typical ComfyUI patterns
    const patterns = {
        workflow: [
            /\{"[^"]*":\s*\{"inputs":/g,  // ComfyUI workflow pattern
            /\{"\d+":\s*\{"inputs":/g,    // Node ID pattern
            /\{"nodes":\s*\[/g,           // Workflow nodes pattern
            /\{"last_node_id":/g          // ComfyUI workflow metadata
        ],
        prompt: [
            /\{"\d+":\s*\{"class_type":/g, // ComfyUI prompt pattern
            /\{"client_id":/g              // ComfyUI client pattern
        ]
    };

    const searchPatterns = patterns[type] || [];

    for (const pattern of searchPatterns) {
        const matches = str.matchAll(pattern);

        for (const match of matches) {
            const startPos = match.index;
            const jsonStr = extractJSONFromPosition(str, startPos);

            if (jsonStr) {
                try {
                    // Validate it's proper JSON
                    JSON.parse(jsonStr);
                    return jsonStr;
                } catch (e) {
                    // Continue searching
                }
            }
        }
    }

    return null;
}

/**
 * Extract complete JSON object starting from a position
 * @param {string} str - String containing JSON
 * @param {number} startPos - Starting position
 * @returns {string|null} Complete JSON string or null
 */
function extractJSONFromPosition(str, startPos) {
    let braceCount = 0;
    let inString = false;
    let escaped = false;
    let jsonStart = -1;

    for (let i = startPos; i < str.length; i++) {
        const char = str[i];

        if (escaped) {
            escaped = false;
            continue;
        }

        if (char === '\\' && inString) {
            escaped = true;
            continue;
        }

        if (char === '"') {
            inString = !inString;
        }

        if (!inString) {
            if (char === '{') {
                if (jsonStart === -1) jsonStart = i;
                braceCount++;
            } else if (char === '}') {
                braceCount--;
                if (braceCount === 0 && jsonStart !== -1) {
                    return str.slice(jsonStart, i + 1);
                }
            }
        }
    }

    return null;
}

/**
 * Parse ComfyUI workflow and prompt data into standard SD parameters
 * @param {Object} workflowData - Parsed workflow JSON
 * @param {Object} promptData - Parsed prompt JSON
 * @returns {Object} Standardized parameters object
 */
function parseComfyUIParameters(workflowData, promptData) {
    const params = {
        prompt: '',
        negativePrompt: '',
        steps: null,
        sampler: '',
        scheduler: '',
        cfgScale: null,
        seed: null,
        size: { width: null, height: null },
        model: '',
        modelHash: '',
        clipSkip: null,
        denoisingStrength: null,
        version: 'ComfyUI',
        other: {}
    };

    try {
        // Extract parameters from prompt data (more reliable for generation params)
        if (promptData) {
            for (const [nodeId, nodeData] of Object.entries(promptData)) {
                if (typeof nodeData !== 'object' || !nodeData.class_type) continue;

                const { class_type, inputs } = nodeData;

                // Text prompts
                if (class_type === 'CLIPTextEncode' && inputs.text) {
                    // Determine if positive or negative based on connections or context
                    const text = inputs.text.trim();
                    if (!params.prompt) {
                        params.prompt = text;
                    } else if (!params.negativePrompt) {
                        params.negativePrompt = text;
                    }
                }

                // KSampler parameters
                if (class_type === 'KSampler' || class_type === 'KSamplerAdvanced') {
                    if (inputs.steps) params.steps = inputs.steps;
                    if (inputs.cfg) params.cfgScale = inputs.cfg;
                    if (inputs.sampler_name) params.sampler = inputs.sampler_name;
                    if (inputs.scheduler) params.scheduler = inputs.scheduler;
                    if (inputs.seed) params.seed = inputs.seed;
                    if (inputs.denoise) params.denoisingStrength = inputs.denoise;
                }

                // Image dimensions
                if (class_type === 'EmptyLatentImage') {
                    if (inputs.width) params.size.width = inputs.width;
                    if (inputs.height) params.size.height = inputs.height;
                }

                // Model information
                if (class_type === 'CheckpointLoaderSimple' && inputs.ckpt_name) {
                    params.model = inputs.ckpt_name;
                }

                // CLIP Skip
                if (class_type === 'CLIPSetLastLayer' && inputs.stop_at_clip_layer) {
                    params.clipSkip = inputs.stop_at_clip_layer;
                }
            }
        }

        // Extract additional info from workflow data
        if (workflowData && workflowData.nodes) {
            for (const node of workflowData.nodes) {
                if (!node.type || !node.widgets_values) continue;

                // Extract text from text nodes
                if (node.type === 'CLIPTextEncode') {
                    const text = node.widgets_values[0];
                    if (text && typeof text === 'string') {
                        if (!params.prompt) {
                            params.prompt = text.trim();
                        } else if (!params.negativePrompt && text.trim() !== params.prompt) {
                            params.negativePrompt = text.trim();
                        }
                    }
                }

                // Extract sampler settings
                if (node.type === 'KSampler' || node.type === 'KSamplerAdvanced') {
                    const values = node.widgets_values;
                    if (values.length >= 5) {
                        if (!params.seed && values[0]) params.seed = values[0];
                        if (!params.steps && values[1]) params.steps = values[1];
                        if (!params.cfgScale && values[2]) params.cfgScale = values[2];
                        if (!params.sampler && values[3]) params.sampler = values[3];
                        if (!params.scheduler && values[4]) params.scheduler = values[4];
                        if (!params.denoisingStrength && values[5]) params.denoisingStrength = values[5];
                    }
                }

                // Extract dimensions
                if (node.type === 'EmptyLatentImage' && node.widgets_values.length >= 2) {
                    if (!params.size.width) params.size.width = node.widgets_values[0];
                    if (!params.size.height) params.size.height = node.widgets_values[1];
                }
            }
        }

        // Store raw data for reference
        if (workflowData) params.other.workflow = workflowData;
        if (promptData) params.other.promptData = promptData;

    } catch (error) {
        params.other.parseError = error.message;
    }

    return params;
}

/**
 * Format SD metadata for display
 * @param {Object} metadata - Metadata object from extractSDMetadata
 * @returns {string} HTML string for display
 */
export function formatSDMetadataForDisplay(metadata) {
    if (!metadata.hasSDMetadata) {
        return '<div class="sd-no-metadata">No Stable Diffusion metadata found</div>';
    }

    const params = metadata.parsedParameters;
    let html = '<div class="sd-metadata-display">';

    // Positive prompt
    if (params.prompt) {
        html += `
            <div class="sd-section sd-prompt">
                <label class="sd-label">Prompt:</label>
                <div class="sd-value sd-prompt-text">${escapeHtml(params.prompt)}</div>
            </div>
        `;
    }

    // Negative prompt
    if (params.negativePrompt) {
        html += `
            <div class="sd-section sd-negative-prompt">
                <label class="sd-label">Negative Prompt:</label>
                <div class="sd-value sd-negative-text">${escapeHtml(params.negativePrompt)}</div>
            </div>
        `;
    }

    // Generation parameters
    html += '<div class="sd-section sd-params"><label class="sd-label">Parameters:</label><div class="sd-params-grid">';

    const paramsList = [
        ['Steps', params.steps],
        ['Sampler', params.sampler],
        ['Scheduler', params.scheduler],
        ['CFG Scale', params.cfgScale],
        ['Seed', params.seed],
        ['Size', params.size.width && params.size.height ? `${params.size.width}x${params.size.height}` : null],
        ['Model', params.model],
        ['CLIP Skip', params.clipSkip],
        ['Denoising Strength', params.denoisingStrength]
    ];

    for (const [label, value] of paramsList) {
        if (value !== null && value !== undefined && value !== '') {
            html += `<div class="sd-param"><span class="sd-param-label">${label}:</span> <span class="sd-param-value">${escapeHtml(String(value))}</span></div>`;
        }
    }

    html += '</div></div>';

    // ComfyUI specific info
    if (metadata.workflowData) {
        const nodeCount = metadata.workflowData.nodes ? metadata.workflowData.nodes.length : 0;
        html += `
            <div class="sd-section sd-workflow-info">
                <label class="sd-label">ComfyUI Workflow:</label>
                <div class="sd-value">
                    <span class="sd-workflow-nodes">${nodeCount} nodes</span>
                    <button class="sd-workflow-btn" onclick="window.showComfyUIWorkflow && window.showComfyUIWorkflow(this)" 
                            data-workflow='${escapeHtml(JSON.stringify(metadata.workflowData))}'>
                        View Workflow
                    </button>
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}

/**
 * Get CSS styles for SD metadata display
 * @returns {string} CSS string
 */
export function getSDMetadataCSS() {
    return `
        .sd-metadata-display {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
        }
        
        .sd-section {
            margin-bottom: 12px;
            position: relative;
        }
        
        .sd-label {
            font-weight: 600;
            color: #2c3e50;
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .sd-value {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }
        
        .sd-prompt-text, .sd-negative-text {
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .sd-negative-text {
            border-left-color: #e74c3c;
        }
        
        .sd-params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 6px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #27ae60;
        }
        
        .sd-param {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
        }
        
        .sd-param-label {
            font-weight: 500;
            color: #555;
        }
        
        .sd-param-value {
            color: #333;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        
        .sd-workflow-info .sd-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left-color: #9b59b6;
        }
        
        .sd-workflow-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .sd-workflow-btn:hover {
            background: #8e44ad;
        }
        
        .sd-no-metadata {
            color: #666;
            font-style: italic;
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        /* Copy button styles (used by integration) */
        .sd-copy-all-btn:hover {
            background: #106ba3 !important;
        }
    `;
}

/**
 * Escape HTML special characters
 * @param {string} text - Text to escape
 * @returns {string} Escaped text
 */
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}